var fs = require("fs");
const path = require("path");
const extractSchema = require("./extract-schema");

module.exports = async function (opts) {
  let cwd = process.cwd();
  if (!path.isAbsolute(cwd)) {
    cwd = path.resolve(process.cwd(), cwd);
  }
  const entrypoint = path.resolve(cwd, opts.entrypoint);
  const allowedDependencies = opts.dependencies
    ? opts.dependencies.split(",")
    : [];
  const configSchema = await extractSchema(entrypoint, allowedDependencies);
  const docString = generateDocFromSchema(configSchema);
  const docUrl =
    "https://github.com/openmrs/openmrs-esm-module-config#openmrs-esm-module-config";
  const preamble =
    "See the [openmrs-esm-module-config docs](" +
    docUrl +
    ")\nfor information about how to provide configuration files.\n";
  appendOrReplaceDocstring(opts.outfile, preamble + docString);
};

function generateDocFromSchema(schema, keyPath = []) {
  let doc = "";
  for (let key of Object.keys(schema)) {
    if (
      !["default", "description", "validators"].includes(key) &&
      isOrdinaryObject(schema[key])
    ) {
      const thisKeyPath = keyPath.concat([key]);
      const indents = "  ".repeat(keyPath.length);
      const startStr = "\n" + indents + "- ";
      const isLeaf = schema[key].hasOwnProperty("default");
      doc +=
        startStr +
        (isLeaf ? "**" + key + "**" + defaultText(schema[key].default) : key);
      doc += descriptionText(schema[key].description, indents);
      doc += generateDocFromSchema(schema[key], thisKeyPath); // recurse
      doc += validatorText(schema[key].validators, indents);
    }
  }
  return doc;
}

function defaultText(defaultStr) {
  return " *(default: " + defaultStr + ")*";
}

function descriptionText(description, indents) {
  return description ? "\\\n  " + indents + description : "";
}

function validatorText(validators, indents) {
  if (!validators) {
    return "";
  }
  for (let v of validators) {
    if (!v) {
      console.warn(
        "Schema uses an unknown validator. Check that you are using the latest version of @openmrs/esm-cli."
      );
    }
  }
  const validatorMessages = validators.filter((v) => v).map((v) => v()); // all validators should fail for undefined
  return "\\\n  " + indents + "*" + validatorMessages.join(". ") + ".*";
}

function appendOrReplaceDocstring(outfile, docString) {
  const inputString = fs.readFileSync(outfile, "utf8");
  const outputString = updateReadmeString(inputString, docString);
  fs.writeFileSync(outfile, outputString);
}

function updateReadmeString(readme, docString) {
  const indicatorComment = "<!-- GENERATED BY OPENMRS CONFIG CLI -->";
  const indicatorClose = "<!-- END OF GENERATED -->";
  const regexp = new RegExp(indicatorComment + "[\\s\\S]*" + indicatorClose);
  const newContent =
    indicatorComment + "\n" + docString + "\n" + indicatorClose;
  if (readme.match(regexp)) {
    readme = readme.replace(regexp, newContent);
  } else {
    const header = "\n\n## Configuration\n";
    readme += header + newContent;
  }
  return readme;
}

function isOrdinaryObject(value) {
  return typeof value === "object" && !Array.isArray(value) && value !== null;
}
